# Презентация: ClassLoader и Class в Java

## 1. Введение в ClassLoader

### Что такое ClassLoader?

ClassLoader – это механизм загрузки классов в память JVM. Он позволяет загружать классы динамически, избегая их жёсткого
связывания на этапе компиляции.

### Виды ClassLoader-ов:

- **Bootstrap ClassLoader** – загружает стандартные библиотеки Java (`java.base`), написан на C.
- **Platform ClassLoader** – загружает платформенные модули (`java.sql`, `java.xml`).
- **System ClassLoader** – загружает классы из classpath (`-cp` или `CLASSPATH`).
- **Custom ClassLoader** – пользовательские загрузчики классов, позволяющие загружать классы из нестандартных мест (
  например, из сети, базы данных или зашифрованных файлов).

## 2. Принцип делегирования

Принцип делегирования (Delegation Model) позволяет избежать повторной загрузки классов и следит за тем, чтобы один и тот
же класс не загружался разными загрузчиками, если это не необходимо.

### Как работает делегирование?

1. **Поиск среди уже загруженных классов**:
    - Метод `findLoadedClass(name)` сначала проверяет, был ли уже загружен указанный класс.
    - УЕсли класс найден, он возвращается без повторной загрузки.
2. **Делегирование родительскому загрузчику**:
    - Если класс не найден в загруженных, загрузчик передаёт запрос родительскому `ClassLoader`.
    - Если родительский загрузчик тоже не находит класс, процесс продолжается на текущем уровне.
3. **Загрузка нового класса**:
    - Если родительский загрузчик не справился, вызывается `findClass(name)`, который загружает класс из доступных
      ресурсов.

Такой подход позволяет JVM поддерживать целостность классов в памяти и предотвращает возможные конфликты между классами.

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // Проверяем, был ли класс уже загружен
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        try {
            // Если родительский загрузчик существует, пытаемся загрузить класс через него
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                // Если родителя нет, проверяем bootstrap classloader
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // Родитель не нашел класс, продолжаем поиск
        }
        // Если класс не был найден, выполняем его загрузку
        if (c == null) {
            c = findClass(name);
        }
    }
}
```

## 3. Иерархия ClassLoader-ов

```plaintext
                 [ BootstrapClassLoader ]
                          │
      ┌───────────────────┴───────────────────┐
      │                                       │
[ PlatformClassLoader ]              [ AppClassLoader ]
      │                                       │
      │                               ┌───────┴────────┐
      │                               │                │
      │                      [ URLClassLoader ]   [ CustomClassLoader ]
```

В этой диаграмме:

- **BootstrapClassLoader** загружает стандартные классы из JDK (`java.base`).
- **PlatformClassLoader** загружает платформенные модули (`java.sql`, `java.logging` и др.).
- **AppClassLoader** (или System ClassLoader) загружает классы из classpath (`-cp`).
- **URLClassLoader** позволяет загружать классы из JAR-файлов и URL.
- **CustomClassLoader** – пользовательские загрузчики классов, реализованные для специфических нужд.

## 4. Что значит, что класс загружен в JVM?

Когда говорят, что класс загружен в JVM, это означает, что его байт-код был загружен в память, преобразован в структуру
данных JVM и готов к использованию программой.

### **Этапы загрузки класса в JVM**

1. **Загрузка (Loading)**
    - JVM использует `ClassLoader`, чтобы найти файл `.class`, загрузить его содержимое в память и создать представление
      класса в виде объекта `Class<?>`.
    - Проверяется, был ли этот класс уже загружен (`findLoadedClass(name)`).
    - Если класс не был найден среди загруженных, происходит его загрузка с диска, из сети, JAR-архива или другого
      источника.

2. **Проверка (Verification)**
    - JVM проверяет загруженный байт-код на соответствие спецификации Java.
    - Проверяются структуры данных, сигнатуры методов и корректность доступа к памяти.

3. **Подготовка (Preparation)**
    - Для статических полей класса создаются соответствующие структуры данных в памяти и инициализируются значениями по
      умолчанию (например, `0` для `int`, `null` для ссылок).

4. **Разрешение (Resolution)**
    - JVM заменяет ссылки на другие классы, методы и поля из константного пула на реальные ссылки в памяти.

5. **Инициализация (Initialization)**
    - Выполняется статический блок `static { ... }`, если он есть.
    - Присваиваются значения статическим переменным, если они были явно заданы.

### **Результат загрузки класса**

После прохождения всех этих этапов класс считается **загруженным в JVM**. Это означает, что:

- Его можно использовать в программе (`new MyClass()` или `MyClass.method()`).
- Он хранится в `Method Area` памяти JVM.
- Его `ClassLoader` управляет его жизненным циклом.
- Экземпляры класса могут быть созданы с помощью `new` или рефлексии (`Class.forName("MyClass").newInstance()`).

**Пример загрузки класса в JVM:**

```java
public class Example {
    static {
        System.out.println("Класс Example загружен!");
    }

    public static void main(String[] args) throws ClassNotFoundException {
        Class.forName("Example");
    }
}
```

При выполнении программы, как только `Class.forName("Example")` вызван, JVM загружает `Example.class`, инициализирует
его и выводит:

```
Класс Example загружен!
```

Таким образом, загруженный в JVM класс – это не просто `.class`-файл, а активный объект в памяти, который прошёл процесс
подготовки, инициализации и теперь может использоваться в программе.

## 5. Что такое classpath и CLASSPATH??

### Настройка classpath

**`classpath`** – это специальная настройка JVM, которая определяет, где следует искать `.class`-файлы при выполнении
программы. По умолчанию JVM ищет классы в текущей директории, если `classpath` не задан явно.

### Переменная окружения `CLASSPATH`

Переменная `CLASSPATH` определяет пути, по которым JVM ищет `.class`-файлы и JAR-библиотеки. Она полезна, если нужно
настроить окружение так, чтобы JVM автоматически находила нужные классы при каждом запуске программы.

#### Когда использовать `CLASSPATH`?

- Если необходимо, чтобы путь к классам и библиотекам был доступен для всех запусков без явного указания `-cp`.
- В средах автоматизированного развертывания, где удобнее настроить окружение один раз.
- При запуске приложений на серверах или в контейнерах, где пути должны быть заданы статически.

⚠ **Важно**: `CLASSPATH` может привести к проблемам, если в нем остались ненужные пути. В большинстве случаев
рекомендуется явно указывать `-cp` при запуске.

## 5. Методы Class

### Полное имя класса

Полное имя класса (Fully Qualified Name) включает в себя имя пакета и имя класса. Например, для класса `MyClass`,
находящегося в пакете `com.example`, полное имя будет `com.example.MyClass`. Это позволяет избежать конфликтов между
одноимёнными классами в разных пакетах.

### `Class.forName(String name)`

Позволяет загрузить класс по полному имени и выполнить его статическую инициализацию.

```java
public class ForNameExample {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("com.example.MyClass");
        System.out.println("Загружен класс: " + clazz.getName());
    }
}
```

### `newInstance()` (устаревший, заменён на `getDeclaredConstructor().newInstance()`)

Создаёт новый экземпляр класса, используя его конструктор без параметров.

```java
public class NewInstanceExample {
    public static void main(String[] args) throws Exception {
        Class<?> clazz = Class.forName("com.example.MyClass");
        Object obj = clazz.getDeclaredConstructor().newInstance();
        System.out.println("Создан объект: " + obj.toString());
    }
}
```

### `getResourceAsStream(String name)`

Позволяет загрузить ресурс (например, файл) из classpath.

```java
public class ResourceStreamExample {
    public static void main(String[] args) throws Exception {
        InputStream input = ClassLoader.getSystemClassLoader().getResourceAsStream("config.properties");
        if (input != null) {
            Properties props = new Properties();
            props.load(input);
            System.out.println("Приложение: " + props.getProperty("app.name"));
        }
    }
}
```

## 6. Пример работы с ClassLoader-ами

```java
public class DynamicClassLoadingExample {
    public static void main(String[] args) throws Exception {
        ClassLoader customLoader = new MyCustomClassLoader();
        Class<?> clazz = customLoader.loadClass("com.example.DynamicClass");
        System.out.println("Загружен класс: " + clazz.getName());
    }
}
```

## 7. Заключение

ClassLoader – это один из ключевых механизмов JVM, обеспечивающий динамическую загрузку классов в память. Он позволяет
загружать классы по мере необходимости, что делает Java более гибкой и расширяемой.

### Основные выводы:

1. **Иерархия загрузчиков классов**: JVM использует `BootstrapClassLoader`, `PlatformClassLoader` и `AppClassLoader` для
   загрузки стандартных, платформенных и пользовательских классов соответственно.
2. **Принцип делегирования**: Каждый загрузчик передаёт запрос родителю, прежде чем загружать класс самостоятельно. Это
   предотвращает дублирование классов и повышает безопасность.
3. **Classpath и CLASSPATH**: ClassLoader загружает классы из путей, указанных в `classpath` или переменной окружения
   `CLASSPATH`. Лучше использовать `-cp` при запуске программы, чем глобально изменять `CLASSPATH`.
4. **Методы Class**:Использование `Class.forName()`, `newInstance()`, `getResourceAsStream()` позволяет загружать классы
   динамически и управлять ими во время выполнения программы.
5. **Пользовательские ClassLoader-ы**: Можно создавать собственные загрузчики для специфичных задач, таких как загрузка
   классов из сети, шифрованных файлов или базы данных.

### Практическое применение:

- Разработка плагинов (например, в IDE, браузерах, серверах приложений).
- Динамическая загрузка модулей без перезапуска программы.
- Обеспечение изоляции классов в контейнеризированных средах.

Владение механизмом ClassLoader позволяет лучше понимать работу JVM и писать более гибкие, расширяемые и безопасные
Java-приложения.

