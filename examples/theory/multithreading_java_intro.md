## Вводный материал по многопоточности в Java

### 1. Что такое многопоточность?

- Многопоточность — это возможность выполнения нескольких потоков параллельно
- Java изначально разрабатывалась с поддержкой многопоточности и содержит встроенные средства для работы с потоками:
  - Класс `Thread`
  - Интерфейс `Runnable`
  - Ключевые слова `synchronized`, `volatile`
  - Пакеты `java.util.concurrent`, `java.util.concurrent.atomic`
- Преимущества:
  - Повышение производительности
  - Улучшение отклика приложений
  - Эффективное использование ресурсов

### 2. Процессы и потоки

- Процесс: независимая программа с собственной памятью
- Поток: единица выполнения внутри процесса
- Потоки одного процесса:
  - Делят память
  - Имеют отдельные стеки вызовов

**Особенности потоков в JVM:**

- Потоки в Java реализованы на основе потоков операционной системы (native threads)
- Планирование выполнения потоков осуществляется операционной системой, Java не гарантирует порядок выполнения
- JVM создаёт собственные потоки (например, для сборки мусора, JIT-компиляции и др.)
- Потоки могут быть пользовательскими (создаваемыми вручную) или системными (управляемыми JVM)
- При завершении программы необходимо следить, чтобы не оставались не завершённые пользовательские потоки — они могут помешать корректному завершению процесса

### 3. Создание потоков в Java

- Наследование от `Thread`:

```java
class MyThread extends Thread {
  public void run() {
    System.out.println("Привет из потока!");
  }
}
new MyThread().start();
```

- Использование `Runnable`:

```java
Runnable task = () -> System.out.println("Привет из потока!");
new Thread(task).start();
```

**Сравнение подходов:**

- `Thread` следует использовать, если вы создаёте специализированный поток с расширением поведения и вам не нужно использовать другой родительский класс (так как Java не поддерживает множественное наследование).
- `Runnable` предпочтительнее, когда вы хотите отделить выполнение задачи от механизма запуска потока. Это даёт большую гибкость, позволяет использовать пул потоков (`ExecutorService`), и ваш класс может наследоваться от другого класса одновременно.
- Использование `Runnable` способствует лучшей архитектуре и переиспользованию кода, особенно в многопоточном программировании на практике.

### 4. Состояния потока

- **NEW** — поток создан, но метод `start()` ещё не вызван
- **RUNNABLE** — метод `start()` вызван, поток готов к выполнению и ожидает планирования
- **RUNNING** — поток выполняется, т.е. планировщик выбрал его для выполнения
- **BLOCKED** — поток пытается войти в синхронизированный блок/метод, но монитор занят другим потоком
- **WAITING** — поток ожидает другого потока для пробуждения (например, вызов `wait()` без тайм-аута)
- **TIMED\_WAITING** — поток ожидает в течение определённого времени (например, `sleep(ms)`, `join(ms)`, `wait(ms)`)
- **TERMINATED** — поток завершил выполнение либо из-за завершения метода `run()`, либо из-за исключения

**Возможные переходы между состояниями:**

- `NEW` → `RUNNABLE` — при вызове `start()`

- `RUNNABLE` → `RUNNING` — когда планировщик выбирает поток для выполнения

- `RUNNING` → `BLOCKED` — при попытке войти в занятый синхронизированный блок

- `RUNNING` → `WAITING` — при вызове `wait()` без тайм-аута или `join()` без тайм-аута

- `RUNNING` → `TIMED_WAITING` — при вызове `sleep()`, `wait(ms)`, `join(ms)`, `parkNanos()` и т.п.

- `WAITING` / `TIMED_WAITING` → `RUNNABLE` — при пробуждении (например, `notify()`, `notifyAll()` или истечении таймера)

- `BLOCKED` → `RUNNABLE` — как только монитор становится доступным

- `RUNNING` → `TERMINATED` — после завершения метода `run()` или при возникновении необработанного исключения

### 5. Пример ошибки инкрементации счётчика из разных потоков

Когда несколько потоков одновременно выполняют операцию `count++`, результат может оказаться неожиданным. Это происходит потому, что `count++` — не атомарная операция, а последовательность нескольких действий на уровне байткода:

1. Загрузка текущего значения (`load`)
2. Увеличение значения (`increment`)
3. Запись результата обратно (`store`)

Если два потока выполняют `count++` одновременно, они могут оба считать одно и то же значение и затем записать его, потеряв одно из увеличений.

**Пример:**

```java
class Counter {
    int count = 0;

    void increment() {
        count++;
    }
}

Counter counter = new Counter();
Runnable task = () -> {
    for (int i = 0; i < 1000; i++) {
        counter.increment();
    }
};

Thread t1 = new Thread(task);
Thread t2 = new Thread(task);
t1.start();
t2.start();
t1.join();
t2.join();

System.out.println(counter.count); // Ожидалось 2000, может быть меньше
```

**Решения:**

- Использовать `synchronized` в методе `increment()`
- Использовать `AtomicInteger`, который обеспечивает атомарность

Это классический пример race condition, который возникает при отсутствии надлежащей синхронизации.

### 6. Синхронизация&#x20;

- Race condition — ошибка при одновременном доступе к общим данным

- Решение — ключевое слово `synchronized`

**Примеры использования synchronized:**

- Синхронизация метода:

```java
public synchronized void increment() {
    count++;
}
```

- Синхронизация блока:

```java
public void increment() {
    synchronized (this) {
        count++;
    }
}
```

- Синхронизация по внешнему объекту:

```java
private final Object lock = new Object();

public void doSomething() {
    synchronized (lock) {
        // защищённая логика
    }
}
```

**Внутренняя реализация synchronized:**

- `synchronized` использует механизм мониторов (monitor locks), встроенных в каждый объект в Java
- Когда поток входит в синхронизированный блок или метод, он пытается захватить монитор объекта
- Если монитор уже захвачен другим потоком, текущий поток переходит в состояние BLOCKED
- Когда монитор освобождается, поток переходит в RUNNABLE и может быть запущен планировщиком
- Эти механизмы управляются JVM и не требуют вмешательства со стороны разработчика

**Что такое monitor lock:**

- Каждый объект в Java содержит внутреннюю структуру, называемую монитором (monitor lock)

- Монитор — это синхронизирующий механизм, встроенный в объектную модель JVM

- Когда поток входит в синхронизированный блок или метод, он должен захватить монитор объекта

- Захват монитора происходит с помощью инструкций `monitorenter` и `monitorexit` на уровне байткода

- `monitorenter` помещает поток в очередь ожидания, если монитор уже занят другим потоком

- Монитор может быть рекурсивно захвачен — если поток уже владеет монитором, он может войти в синхронизированный код снова без блокировки

- Каждый вход в монитор должен соответствовать выходу — при нарушении возникает исключение `IllegalMonitorStateException`

- JVM использует различные реализации мониторов: наивные (mutex), оптимизированные (spin-locks, lightweight locks), в зависимости от уровня конкуренции и архитектуры

### 7. AtomicInteger

- Класс `AtomicInteger` из пакета `java.util.concurrent.atomic` предоставляет атомарные операции над целочисленными значениями без необходимости использовать `synchronized`
- Все методы `AtomicInteger` используют низкоуровневые механизмы из `Unsafe` и реализованы с использованием CAS (Compare-And-Swap) инструкций, которые позволяют реализовать блокировки без ожидания
- Примеры методов: `incrementAndGet()`, `getAndIncrement()`, `compareAndSet(expected, update)`

**Пример использования:**

```java
import java.util.concurrent.atomic.AtomicInteger;

class Counter {
    AtomicInteger count = new AtomicInteger(0);

    void increment() {
        count.incrementAndGet();
    }
}
```

- Благодаря атомарности операций, можно безопасно вызывать `increment()` из нескольких потоков без дополнительных синхронизаций
- Подходит для простых счётчиков, индексов и других числовых операций, где важна производительность

### 8. Volatile

- Ключевое слово `volatile` сообщает JVM, что доступ к переменной должен быть напрямую через основную (main) память, а не кэшированную копию в регистрах или CPU cache

- При записи в `volatile` переменную:

  - Все предыдущие записи в текущем потоке (до записи) становятся видимыми другим потокам (semantics of release)
  - Значение переменной записывается в основную память

- При чтении из `volatile` переменной:

  - Все последующие чтения видят значение из основной памяти (semantics of acquire)
  - Чтение переменной происходит из основной памяти, минуя локальные кэши

- На уровне процессора это может быть реализовано с помощью memory barriers (ограничителей переупорядочивания инструкций)

- `volatile` не обеспечивает атомарности операций (например, `x++` всё равно небезопасно)

- Подходит, когда одна переменная обновляется одним потоком и читается другими без сложных условий гонки

### 9. Отношение "happens-before" и Java Memory Model

- **Java Memory Model (JMM)** определяет, как потоки взаимодействуют через общую память и какие гарантии существуют для видимости изменений между потоками

- Отношение **happens-before** — фундаментальное понятие в JMM, описывающее порядок, в котором действия одного потока становятся видимыми другому потоку

- Если операция A "happens-before" операции B, то все изменения, сделанные в A, гарантированно видны в B

**Основные правила happens-before:**

- Вызов `Thread.start()` для потока T происходит "happens-before" любым действиям в потоке T

- Завершение потока (например, `Thread.join()`) происходит "happens-before" кодом после `join()`

- Запись в переменную с `volatile` происходит "happens-before" чтением этой переменной другим потоком

- Выход из синхронизированного блока/метода происходит "happens-before" входом другого потока в тот же блок/метод на том же мониторе

- Использование синхронизации (`synchronized`, `volatile`, `Lock`) важно не только для атомарности, но и для установления правильных "happens-before" отношений

- Без отношения "happens-before" компилятор или процессор может переупорядочить инструкции, и другой поток может видеть устаревшие или неконсистентные данные

**Примеры happens-before с synchronized и volatile:**

- С использованием `synchronized`:

```java
synchronized (lock) {
    sharedVar = 42; // запись
}

synchronized (lock) {
    System.out.println(sharedVar); // чтение
}
```

Здесь гарантировано, что если первый поток вышел из синхронизированного блока, а второй вошёл в него позже, он увидит `sharedVar = 42`, так как выход из блока создает "happens-before" отношение ко входу в тот же монитор другим потоком.

- С использованием `volatile`:

```java
volatile boolean ready = false;
int value = 0;

Thread writer = new Thread(() -> {
    value = 42;            // обычная запись
    ready = true;          // запись в volatile
});

Thread reader = new Thread(() -> {
    if (ready) {           // чтение volatile
        System.out.println(value); // гарантированно увидит value = 42
    }
});
```

Запись в `ready` создаёт "happens-before" по отношению к чтению этой переменной, что гарантирует, что `value = 42` также станет видимым.

### 10. Вывод

- Java предоставляет мощные встроенные средства для многопоточности: классы `Thread`, `Runnable`, ключевые слова `synchronized`, `volatile`, а также современные конструкции из пакета `java.util.concurrent`
- Потоки делят память, но имеют независимое выполнение, что требует внимательного подхода к синхронизации и согласованности данных
- Java Memory Model и отношение "happens-before" определяют правила видимости и упорядочивания операций между потоками
- Работа с многопоточностью требует аккуратности, тестирования и понимания внутренней реализации примитивов синхронизации
